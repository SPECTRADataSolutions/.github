name: tally-feature-devotion

on:
  issues:
    types: [labeled, unlabeled, edited]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write # needs write to comment and label
  pull-requests: read

jobs:
  tally:
    runs-on: ubuntu-latest
    steps:
      - name: fetch-devotion-policy
        id: devotionPolicy
        uses: ./.github/actions/fetch-policy
        with:
          file: devotion.policy.yaml
      - name: compute-devotion
        uses: actions/github-script@v7
        with:
          script: |
            // Feature Devotion Tally via composite policy action
            const raw = `${{ steps.devotionPolicy.outputs.content }}`;
            core.summary.addHeading('Devotion Policy Fetch')
              .addRaw(`exists: ${{ steps.devotionPolicy.outputs.exists }} sha256: ${{ steps.devotionPolicy.outputs.sha256 }}`)
              .addBreak().write();
            function parseFeatureDevotion(y){
              const feature={};
              let inSection=false; let currentListKey=null;
              for(const ln of y.split(/\r?\n/)){
                if(/^\s*featureDevotion:\s*$/.test(ln)){ inSection=true; continue; }
                if(inSection){
                  if(/^\s{2}[A-Za-z0-9_]+:/.test(ln)){
                    const m=ln.match(/^\s{2}([A-Za-z0-9_]+):\s*(.*)$/);
                    if(m){ currentListKey=null; feature[m[1]]=m[2] ? m[2].split('#')[0].trim() : ''; }
                    continue;
                  }
                  if(/^\s{2}[A-Za-z0-9_]+:\s*$/.test(ln)){
                    const m=ln.match(/^\s{2}([A-Za-z0-9_]+):\s*$/); if(m){ currentListKey=m[1]; feature[currentListKey]=[]; continue; }
                  }
                  if(currentListKey && /^\s{4}-\s+/.test(ln)){
                    const v=ln.replace(/^\s{4}-\s+/,'').trim(); feature[currentListKey].push(v.replace(/#.*$/,'').trim()); continue;
                  }
                  if(/^\S/.test(ln)) { // new top-level section
                    break;
                  }
                }
              }
              return feature;
            }
            let feature={};
            try { feature = parseFeatureDevotion(raw); } catch(e){ core.warning('Parse failure, defaults'); }
            const num = (k,d)=> parseInt((feature[k]||'').toString(),10)||d;
            const threshold = num('threshold',20);
            const endorsementWeight = num('endorsementWeight',3);
            const councilBoostValue = num('councilBoost',5);
            const councilLabel = feature.councilEndorsedLabel || 'council-endorsed';
            const labelOnReach = feature.labelOnReach || 'roadmap-candidate';
            const positiveReactions = Array.isArray(feature.positiveReactions) && feature.positiveReactions.length? feature.positiveReactions : ['+1','hooray','heart','rocket'];
            // Support both issue and issue_comment events
            let issue = context.payload.issue;
            if (!issue && context.payload.comment?.issue_url) {
              try { const r = await github.request(context.payload.comment.issue_url); issue = r.data; } catch(e){ console.log('Fetch issue failed', e.message); return; }
            }
            if (!issue) { console.log('No issue context'); return; }

            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const isFeature = labels.includes('type:feature') || /^ðŸŒŸ \[Feature]/.test(issue.title || '');
            const hasPrayer = labels.includes('prayer');
            if (!(isFeature && hasPrayer)) { console.log('Not a feature with prayer label'); return; }

            const owner = context.repo.owner; const repo = context.repo.repo; const issue_number = issue.number;

            async function collect(pagerFn) {
              let page=1, per_page=100, all=[]; while(true){ const res=await pagerFn(page, per_page); all=all.concat(res.data); if(res.data.length<per_page) break; page++; } return all; }
            const reactions = await collect((page, per_page)=> github.request('GET /repos/{owner}/{repo}/issues/{issue_number}/reactions',{owner,repo,issue_number,page,per_page, headers:{'Accept':'application/vnd.github+json'}}));
            const positiveSet = new Set(positiveReactions);
            const reactionScore = reactions.filter(r=> positiveSet.has(r.content)).length;

            const comments = await collect((page, per_page)=> github.request('GET /repos/{owner}/{repo}/issues/{issue_number}/comments',{owner,repo,issue_number,page,per_page}));
            const endorsements = comments.filter(c=> /(\b|^)\/endorse(\b|$)/i.test(c.body||'')).length;
            const councilBoost = labels.includes(councilLabel) ? councilBoostValue : 0;
            const tally = reactionScore + (endorsements * endorsementWeight) + councilBoost;
            const remaining = Math.max(0, threshold - tally);

            const marker='<!-- devotion-tally -->';
            const statusLine = tally >= threshold ? `âœ… Threshold reached (>= ${threshold}). Consider roadmap promotion.` : `Progress: ${tally}/${threshold} (remaining ${remaining})`;
            const body = `${marker}\nDevotion tally: **${tally}** (reactions: ${reactionScore}, endorsements: ${endorsements} Ã—3, councilBoost: ${councilBoost})\n${statusLine}`;

            const existing = comments.find(c => c.user?.type === 'Bot' && (c.body||'').includes(marker));
            if (existing) {
              await github.request('PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}', {owner,repo, comment_id: existing.id, body});
              console.log('Updated existing tally comment');
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
              console.log('Created tally comment');
            }

            if (tally >= threshold) {
              try { await github.rest.issues.addLabels({ owner, repo, issue_number, labels:[labelOnReach]}); } catch(e){ console.log('Add label failed', e.message); }
            }
            core.summary.addHeading('Feature Devotion Tally').addRaw(`Tally ${tally}/${threshold} Remaining ${remaining}`).write();
