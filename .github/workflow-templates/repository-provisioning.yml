name: repository-provisioning

# Canonical governed repository provisioning workflow (creates & bootstraps new repositories)
on:
  workflow_dispatch:
    inputs:
      repoName:
        description: "service (camelCase) — becomes repository name"
        required: true
        type: string
      templateRepo:
        description: "Optional template repository org/name (must be within org)"
        required: false
        type: string
      pillar:
        description: "Guidance|Innovation|Engagement|Execution|Protection|Sustenance|Growth"
        required: true
        type: string
      domain:
        description: "single-token camelCase (e.g. platformSecurity)"
        required: true
        type: string
      capability:
        description: "single-token camelCase (e.g. threatDetection)"
        required: true
        type: string
      repoType:
        description: "engineering|execution|applications|governance|content"
        required: true
        type: string
      visibility:
        description: "public or private"
        required: true
        type: string
        default: private
      description:
        description: "Short description of purpose and scope"
        required: true
        type: string
      homepage:
        description: "Optional homepage URL"
        required: false
        type: string
  workflow_call:
    inputs:
      repoName:
        description: "service (camelCase) — becomes repository name"
        type: string
        required: true
      templateRepo:
        description: "Optional template repository org/name (must be within org)"
        type: string
        required: false
      pillar:
        description: "Guidance|Innovation|Engagement|Execution|Protection|Sustenance|Growth"
        type: string
        required: true
      domain:
        description: "single-token camelCase (e.g. platformSecurity)"
        type: string
        required: true
      capability:
        description: "single-token camelCase (e.g. threatDetection)"
        type: string
        required: true
      repoType:
        description: "engineering|execution|applications|governance|content"
        type: string
        required: true
      visibility:
        description: "public or private"
        type: string
        default: private
        required: true
      description:
        description: "Short description of purpose and scope"
        type: string
        required: true
      homepage:
        description: "Optional homepage URL"
        type: string
        required: false
    secrets:
      SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_ID:
        required: true
      SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_PRIVATE_KEY:
        required: true
      SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_INSTALLATION_ID:
        required: true

permissions:
  contents: write
  issues: write

jobs:
  create:
    runs-on: ubuntu-latest
    steps:
      - name: preflight-secrets
        run: |
          missing=0
          for v in SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_ID SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_PRIVATE_KEY SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_INSTALLATION_ID; do
            if [ -z "${!v}" ]; then echo "::error::Missing required secret $v"; missing=1; fi
          done
          if [ $missing -ne 0 ]; then exit 1; fi
        env:
          SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_ID: ${{ secrets.SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_ID }}
          SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_PRIVATE_KEY: ${{ secrets.SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_PRIVATE_KEY }}
          SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_INSTALLATION_ID: ${{ secrets.SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_INSTALLATION_ID }}
      - name: authenticate-github-app
        id: app-auth
        env:
          NEW_APP_ID: ${{ secrets.SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_ID }}
          NEW_APP_PK: ${{ secrets.SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_PRIVATE_KEY }}
          NEW_INSTALLATION_ID: ${{ secrets.SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_INSTALLATION_ID }}
        uses: actions/github-script@v7
        with:
          script: |
            const crypto = require('crypto');
            const appId = process.env.NEW_APP_ID;
            const pk = process.env.NEW_APP_PK;
            const instId = process.env.NEW_INSTALLATION_ID;
            if(!appId || !pk || !instId){ core.setFailed('Missing required GitHub App secrets (expect SPECTRA_REPOSITORY_PROVISIONING_GITHUB_APP_*).'); return; }
            function b64(o){ return Buffer.from(JSON.stringify(o)).toString('base64url'); }
            const now=Math.floor(Date.now()/1000);
            const jwt = [b64({alg:'RS256',typ:'JWT'}), b64({iat:now-60, exp:now+600, iss:appId})];
            const signer=crypto.createSign('RSA-SHA256'); signer.update(jwt.join('.')); signer.end();
            const sig=signer.sign(pk,'base64url'); const tokenJWT=jwt.join('.')+'.'+sig;
            const { data: tokenData } = await github.request('POST /app/installations/{installation_id}/access_tokens',{ installation_id: instId, headers:{ Authorization:`Bearer ${tokenJWT}`, Accept:'application/vnd.github+json'}});
            core.setSecret(tokenData.token); core.setOutput('token', tokenData.token);
      - name: fetch-pillar-policy
        id: pillarPolicy
        uses: ./.github/actions/fetch-policy
        with:
          file: pillars.policy.json
      - name: validate-inputs
        id: validateInputs
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const camel = /^[a-z][a-zA-Z0-9]*$/;
            let pillars = [];
            try { const policy = JSON.parse(`${{ steps.pillarPolicy.outputs.content }}`); pillars = policy.canonical || []; } catch(e){ core.warning('Policy parse failed, fallback to static list'); pillars=['Guidance','Innovation','Engagement','Execution','Protection','Sustenance','Growth']; }
            const types = ['engineering','operations','applications','governance','content'];
            const get = n => (core.getInput(n) || '').trim();
            const repoName = get('repoName');
            const pillar = get('pillar');
            const domain = get('domain');
            const capability = get('capability');
            const repoType = get('repoType');
            const visibility = get('visibility').toLowerCase();
            const templateRepo = get('templateRepo');
            const errs = [];
            if (!camel.test(repoName)) errs.push(`repoName must be camelCase: ${repoName}`);
            if (!camel.test(domain)) errs.push(`domain must be camelCase: ${domain}`);
            if (!camel.test(capability)) errs.push(`capability must be camelCase: ${capability}`);
            if (!pillars.includes(pillar)) errs.push(`pillar invalid: ${pillar}`);
            if (!types.includes(repoType)) errs.push(`repoType invalid: ${repoType}`);
            if (!['public','private'].includes(visibility)) errs.push(`visibility invalid: ${visibility}`);
            if (templateRepo) {
              const ownerPrefix = context.repo.owner + '/';
              if (!templateRepo.startsWith(ownerPrefix)) errs.push(`templateRepo must start with ${ownerPrefix}`);
            }
            if (errs.length) core.setFailed(errs.join('\n'));
            core.summary.addHeading('Repository Provisioning Validation')
              .addList(errs.length ? errs : ['All inputs valid'])
              .write();
            core.setOutput('owner', context.repo.owner);
      - name: create-or-reuse-repository
        if: success()
        id: createRepo
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner = '${{ steps.validateInputs.outputs.owner || github.repository_owner }}';
            const name = (core.getInput('repoName')||'').trim();
            const description = (core.getInput('description')||'').trim();
            const homepage = (core.getInput('homepage') || '').trim() || undefined;
            const isPrivate = (core.getInput('visibility')||'').trim().toLowerCase() !== 'public';
            const templateRepo = (core.getInput('templateRepo')||'').trim();
            try {
              await github.rest.repos.get({ owner, repo: name });
              core.notice(`Repository already exists: ${owner}/${name}`);
            } catch (e) {
              if (e.status !== 404) throw e;
              let created;
              if (templateRepo) {
                const [tplOwner, tplName] = templateRepo.split('/');
                created = await github.request('POST /repos/{template_owner}/{template_repo}/generate', {
                  template_owner: tplOwner,
                  template_repo: tplName,
                  owner,
                  name,
                  description,
                  private: isPrivate,
                  include_all_branches: false
                });
              } else {
                created = await github.rest.repos.createInOrg({
                  org: owner,
                  name,
                  description,
                  homepage,
                  private: isPrivate,
                  auto_init: true,
                  has_issues: true,
                  has_projects: true,
                  has_wiki: false
                });
              }
              core.notice(`Created repository: ${created.data.html_url}`);
              try { await github.rest.repos.update({ owner, repo: name, default_branch: 'main' }); } catch(err){ core.warning(`Default branch not set: ${err.message}`); }
            }
            core.setOutput('repoUrl', `https://github.com/${owner}/${name}`);
      - name: seed-labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            try {
              const res = await github.rest.repos.getContent({ owner, repo, path: '.github/labels.json' });
              const labels = JSON.parse(Buffer.from(res.data.content,'base64').toString('utf8'));
              for (const l of labels) {
                try { await github.rest.issues.createLabel({ owner, repo, name: l.name, color: l.color, description: l.description }); }
                catch(e){ if(e.status===422) await github.rest.issues.updateLabel({ owner, repo, name: l.name, color: l.color, description: l.description }); else throw e; }
              }
            } catch(err) { core.warning(`Labels not seeded (missing or inaccessible): ${err.message}`); }
      - name: seed-initial-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim();
            const domain=core.getInput('domain').trim();
            const capability=core.getInput('capability').trim();
            const repoType=core.getInput('repoType').trim();
            const description=core.getInput('description').trim();
            const visibility=core.getInput('visibility').trim().toLowerCase();
            const readme=`# ${repo}\n\n**Dream**: SPECTRA  \n**Pillar**: ${pillar}  \n**Domain**: ${domain}  \n**Capability**: ${capability}  \n**Service**: ${owner}/${repo}\n\n> ${description}\n\n## Purpose\nDescribe purpose.\n`;
            const intent=`dream: SPECTRA\npillar: ${pillar}\ndomain: ${domain}\ncapability: ${capability}\nservice: ${repo}\nrepoType: ${repoType}\nvisibility: ${visibility}\n`;
            async function up(path, content, message){
              const b64=Buffer.from(content,'utf8').toString('base64');
              try { await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, message, content: b64 }); } catch(e){ core.warning(`${path} not written: ${e.message}`); }
            }
            // Skip README seeding if template used and README exists
            const templateUsed = !!(core.getInput('templateRepo')||'').trim();
            if (!templateUsed) await up('README.md', readme, 'chore: seed README');
            await up('meta/intent.yml', intent, 'chore: add intent manifest');
      - name: protect-main-branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            try { await github.rest.repos.updateBranchProtection({ owner, repo, branch: 'main', required_status_checks: null, enforce_admins: true, required_pull_request_reviews: { required_approving_review_count: 1 }, restrictions: null }); }
            catch(e){ core.warning(`Branch protection not applied: ${e.message}`); }
      - name: set-topics
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim().toLowerCase();
            const domain=core.getInput('domain').trim().toLowerCase();
            const capability=core.getInput('capability').trim().toLowerCase();
            try { await github.rest.repos.replaceAllTopics({ owner, repo, names: ['spectra','framework',`pillar-${pillar}`,`domain-${domain}`,`capability-${capability}`] }); } catch(e){ core.warning(`Topics not set: ${e.message}`); }
      - name: output-repo-url
        run: |
          echo "Repo URL: ${{ steps.createRepo.outputs.repoUrl }}"
