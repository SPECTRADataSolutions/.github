name: anchor-integrity
# Spectrafy-Contract:
#   responsibility: Validate context manifest anchors (schema, reachability, size) & emit coverage metrics
#   inputs:
#     - manifestPath (optional) - Path to manifest YAML
#     - coverageThreshold (optional) - % threshold gate
#     - maxTotalMB (optional) - Aggregate size limit
#     - maxAnchorKB (optional) - Per anchor size advisory limit
#   outputs:
#     - coverage.json - Computed coverage + stats
#     - unreachable.txt - List of unreachable anchors (if any)
#     - oversized.txt - Anchors exceeding size advisory
#   metrics:
#     - anchor_coverage: Reachable / total * 100
#     - unreachable_count: Number of unreachable anchors
#     - oversized_count: Anchors over soft size limit
#   idempotent: true
#   autonomous: true
#   ownership: governance
#   replacementPolicy: immediate-remove-legacy
# Consolidated workflow (Phase 1)
# Merges anchor-reachability-and-size + check-context-file validations (schema, coverage, size gates, issue creation)

on:
  schedule:
    - cron: "17 5 * * *"
  workflow_dispatch:
    inputs:
      manifestPath:
        description: Path to context manifest (YAML)
        required: false
        default: context/config/contextManifest.yaml
      coverageThreshold:
        description: Minimum anchor coverage % (reachable / total)
        required: false
        default: "90"
      maxTotalMB:
        description: Max aggregate size (MB) across anchors
        required: false
        default: "50"
      maxAnchorKB:
        description: Soft per-anchor size limit KB
        required: false
        default: "256"
  workflow_call:
    inputs:
      manifestPath:
        type: string
        required: false
        default: context/config/contextManifest.yaml
      coverageThreshold:
        type: number
        required: false
        default: 90
      maxTotalMB:
        type: number
        required: false
        default: 50
      maxAnchorKB:
        type: number
        required: false
        default: 256

permissions:
  contents: read
  issues: write

env:
  CONTRACTS_REPO: SPECTRADataSolutions/.github
  SCHEMA_RELATIVE_PATH: contracts/context/contextManifest.json

jobs:
  integrity:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      MANIFEST_PATH: ${{ inputs.manifestPath || github.event.inputs.manifestPath || 'context/config/contextManifest.yaml' }}
      COVERAGE_THRESHOLD: ${{ inputs.coverageThreshold || github.event.inputs.coverageThreshold || 90 }}
      MAX_TOTAL_MB: ${{ inputs.maxTotalMB || github.event.inputs.maxTotalMB || 50 }}
      MAX_ANCHOR_KB: ${{ inputs.maxAnchorKB || github.event.inputs.maxAnchorKB || 256 }}
    steps:
      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Checkout contracts repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.CONTRACTS_REPO }}
          path: contracts-repo
          sparse-checkout: |
            contracts/context
          sparse-checkout-cone-mode: false
      - name: Setup tooling
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install validators
        run: |
          npm install -g ajv-cli js-yaml
          sudo apt-get update -y
          sudo apt-get install -y jq curl
      - name: Locate manifest
        id: locate
        run: |
          if [ ! -f "$MANIFEST_PATH" ]; then
            echo "::error title=Manifest Missing::No manifest at $MANIFEST_PATH"; exit 1; fi
          echo "path=$MANIFEST_PATH" >> $GITHUB_OUTPUT
      - name: Convert YAML â†’ JSON
        run: js-yaml "$MANIFEST_PATH" > /tmp/contextManifest.json
      - name: Schema validate
        run: |
          SCHEMA="contracts-repo/${{ env.SCHEMA_RELATIVE_PATH }}"
          if [ -f "$SCHEMA" ]; then
            ajv validate -s "$SCHEMA" -d /tmp/contextManifest.json
          else
            echo "::warning title=Schema Missing::Skipping schema validation"
          fi
      - name: Extract size limits
        id: limits
        run: |
          MAX_TOTAL_MB_CFG=$(jq -r '.sizeLimits.maxTotalSizeMB // empty' /tmp/contextManifest.json)
          MAX_FILE_KB_CFG=$(jq -r '.sizeLimits.maxFileSizeKB // empty' /tmp/contextManifest.json)
          echo "maxTotalMB=${MAX_TOTAL_MB_CFG:-$MAX_TOTAL_MB}" >> $GITHUB_OUTPUT
          echo "maxFileKB=${MAX_FILE_KB_CFG:-$MAX_ANCHOR_KB}" >> $GITHUB_OUTPUT
      - name: Scan anchors
        id: scan
        env:
          MAX_FILE_KB: ${{ steps.limits.outputs.maxFileKB }}
          MAX_TOTAL_MB_FINAL: ${{ steps.limits.outputs.maxTotalMB }}
        run: |
          set -e
          TOTAL=0 REACH=0 UNREACH=0 OVERSIZED=0 TOTAL_KB=0
          OVER_LIST="" UNREACH_LIST=""
          jq -r '.allowedRepos[]? | @base64' /tmp/contextManifest.json | while read repo; do
            _json=$(echo "$repo" | base64 -d)
            owner=$(echo "$_json" | jq -r '.owner')
            name=$(echo "$_json" | jq -r '.name')
            for ref in $(echo "$_json" | jq -r '.allowedRefs[]?'); do
              for p in $(echo "$_json" | jq -r '.allowedPaths[]?'); do
                TOTAL=$((TOTAL+1))
                resp=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" -H 'Accept: application/vnd.github.v3+json' "https://api.github.com/repos/$owner/$name/contents/$p?ref=$ref")
                size=$(echo "$resp" | jq -r '.size // -1')
                if [ "$size" -lt 0 ]; then
                  UNREACH=$((UNREACH+1))
                  UNREACH_LIST="$UNREACH_LIST\n- $owner/$name/$p@$ref (not found)"
                  continue
                fi
                kb=$(( (size + 1023)/1024 ))
                TOTAL_KB=$((TOTAL_KB+kb))
                REACH=$((REACH+1))
                if [ "$kb" -gt "$MAX_FILE_KB" ]; then
                  OVERSIZED=$((OVERSIZED+1))
                  OVER_LIST="$OVER_LIST\n- $owner/$name/$p@$ref (${kb}KB)"
                fi
              done
            done
          done
          COVERAGE=0; [ "$TOTAL" -gt 0 ] && COVERAGE=$(( REACH * 100 / TOTAL ))
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "unreachable=$UNREACH" >> $GITHUB_OUTPUT
          echo "oversized=$OVERSIZED" >> $GITHUB_OUTPUT
          echo "oversize_list=$OVER_LIST" >> $GITHUB_OUTPUT
          echo "unreachable_list=$UNREACH_LIST" >> $GITHUB_OUTPUT
          echo "total_mb=$(( TOTAL_KB / 1024 ))" >> $GITHUB_OUTPUT
          [ $(( TOTAL_KB / 1024 )) -gt $MAX_TOTAL_MB ] && echo "size_exceeded=true" >> $GITHUB_OUTPUT || echo "size_exceeded=false" >> $GITHUB_OUTPUT
      - name: Gates
        run: |
          cov=${{ steps.scan.outputs.coverage || '0' }}
          thr=$COVERAGE_THRESHOLD
            if [ "$cov" -lt "$thr" ]; then echo "::error title=Coverage Gate Failed::${cov}% < ${thr}%"; FAIL=1; fi
            if [ "${{ steps.scan.outputs.size_exceeded }}" = "true" ]; then echo "::error title=Size Limit Exceeded::Total MB ${{ steps.scan.outputs.total_mb }} > $MAX_TOTAL_MB"; FAIL=1; fi
            [ "${FAIL:-0}" = 1 ] && exit 1 || echo "Gates passed"
      - name: Gap issue (coverage)
        if: ${{ steps.scan.outputs.coverage != '' && steps.scan.outputs.coverage != '0' && steps.scan.outputs.coverage < env.COVERAGE_THRESHOLD }}
        uses: actions/github-script@v7
        with:
          script: |
            const cov = parseInt('${{ steps.scan.outputs.coverage }}', 10);
            const thr = parseInt('${{ env.COVERAGE_THRESHOLD }}', 10);
            const title = 'ðŸ“Š Context Anchor Coverage Gap';
            const body = `Coverage: ${cov}% (threshold ${thr}%)\nUnreachable: ${{ steps.scan.outputs.unreachable }}\nOversized: ${{ steps.scan.outputs.oversized }}\nTotal Anchors: ${{ steps.scan.outputs.total }}\nOversized List:${{ steps.scan.outputs.oversize_list || '\nNone' }}\nUnreachable List:${{ steps.scan.outputs.unreachable_list || '\nNone' }}`;
            const existing = await github.paginate(github.rest.issues.listForRepo, { ...context.repo, state: 'open', labels: 'coverage:gap' });
            const match = existing.find(i => i.title === title);
            if (match) {
              await github.rest.issues.createComment({ ...context.repo, issue_number: match.number, body });
            } else {
              await github.rest.issues.create({ ...context.repo, title, body, labels: ['type:initiative','coverage:gap','priority:medium'] });
            }
      - name: Summary
        if: always()
        run: |
          echo "## Anchor Integrity" >> $GITHUB_STEP_SUMMARY
          echo "Coverage: ${{ steps.scan.outputs.coverage }}% (threshold $COVERAGE_THRESHOLD%)" >> $GITHUB_STEP_SUMMARY
          echo "Unreachable: ${{ steps.scan.outputs.unreachable }}" >> $GITHUB_STEP_SUMMARY
          echo "Oversized: ${{ steps.scan.outputs.oversized }}" >> $GITHUB_STEP_SUMMARY
          echo "Total: ${{ steps.scan.outputs.total }}" >> $GITHUB_STEP_SUMMARY
