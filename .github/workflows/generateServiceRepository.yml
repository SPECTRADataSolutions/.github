name: generateServiceRepository
on:
  workflow_dispatch:
    inputs:
      repoName:
        description: "service (camelCase) — will become repository name"
        required: true
        type: string
      pillar:
        description: "Guidance|Innovation|Engagement|Operations|Protection|Sustenance|Growth"
        required: true
        type: string
      domain:
        description: "single-token camelCase (e.g. platformSecurity)"
        required: true
        type: string
      capability:
        description: "single-token camelCase (e.g. threatDetection)"
        required: true
        type: string
      repoType:
        description: "engineering|operations|applications|governance|content"
        required: true
        type: string
      visibility:
        description: "public or private"
        required: true
        type: string
        default: "private"
      description:
        description: "Short description of purpose and scope"
        required: true
        type: string
      homepage:
        description: "Optional homepage URL"
        required: false
        type: string

jobs:
  create:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: validateInputs
        uses: actions/github-script@v7
        with:
          script: |
            const camel = /^[a-z][a-zA-Z0-9]*$/;
            const pillars = ['Guidance','Innovation','Engagement','Operations','Protection','Sustenance','Growth'];
            const types = ['engineering','operations','applications','governance','content'];

            const repoName = core.getInput('repoName').trim();
            const pillar = core.getInput('pillar').trim();
            const domain = core.getInput('domain').trim();
            const capability = core.getInput('capability').trim();
            const repoType = core.getInput('repoType').trim();
            const visibility = core.getInput('visibility').trim().toLowerCase();

            if (!camel.test(repoName)) core.setFailed(`repoName must be camelCase: ${repoName}`);
            if (!camel.test(domain)) core.setFailed(`domain must be camelCase: ${domain}`);
            if (!camel.test(capability)) core.setFailed(`capability must be camelCase: ${capability}`);
            if (!pillars.includes(pillar)) core.setFailed(`pillar invalid: ${pillar}`);
            if (!types.includes(repoType)) core.setFailed(`repoType invalid: ${repoType}`);
            if (!['public','private'].includes(visibility)) core.setFailed(`visibility invalid: ${visibility}`);

            core.setOutput('owner', context.repo.owner);

      - name: createRepository
        id: createRepository
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner = '${{ steps.validateInputs.outputs.owner }}';
            const name = core.getInput('repoName').trim();
            const description = core.getInput('description').trim();
            const homepage = (core.getInput('homepage') || '').trim() || undefined;
            const isPrivate = core.getInput('visibility').trim().toLowerCase() !== 'public';

            try {
              // Idempotent: if exists, reuse
              await github.rest.repos.get({ owner, repo: name });
              core.notice(`Repository already exists: ${owner}/${name}`);
              core.setOutput('repoUrl', `https://github.com/${owner}/${name}`);
            } catch (e) {
              if (e.status !== 404) throw e;

              const created = await github.rest.repos.createInOrg({
                org: owner,
                name,
                description,
                homepage,
                private: isPrivate,
                auto_init: true,
                has_issues: true,
                has_projects: true,
                has_wiki: false
              });

              // Best-effort: set default branch to main
              try {
                await github.rest.repos.update({
                  owner,
                  repo: name,
                  default_branch: 'main'
                });
              } catch (err) {
                core.warning(`Default branch not changed to 'main': ${err.message}`);
              }

              core.setOutput('repoUrl', created.data.html_url);
            }

      - name: seedCanonicalLabels
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validateInputs.outputs.owner }}';
            const repo=core.getInput('repoName').trim();

            // Load canonical labels.json from org .github repo
            const res = await github.rest.repos.getContent({
              owner,
              repo: '.github',
              path: '.github/labels.json'
            });

            const labels = JSON.parse(Buffer.from(res.data.content,'base64').toString('utf8'));

            for (const l of labels) {
              try {
                await github.rest.issues.createLabel({ owner, repo, name: l.name, color: l.color, description: l.description });
              } catch(e) {
                if(e.status===422){
                  await github.rest.issues.updateLabel({ owner, repo, name: l.name, color: l.color, description: l.description });
                } else {
                  throw e;
                }
              }
            }

      - name: generateBaselineFiles
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validateInputs.outputs.owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim();
            const domain=core.getInput('domain').trim();
            const capability=core.getInput('capability').trim();
            const repoType=core.getInput('repoType').trim();
            const description=core.getInput('description').trim();
            const visibility=core.getInput('visibility').trim().toLowerCase();

            const readme =
`# ${repo}

<!-- NAV_START -->
**Dream**: SPECTRA  
**Pillar**: ${pillar}  
**Domain**: ${domain}  
**Capability**: ${capability}  
**Service**: ${owner}/${repo}
<!-- NAV_END -->

> ${description}

## Purpose
This service delivers the ${capability} capability within the ${domain} domain of the ${pillar} pillar.

## Structure
- source → extract → clean → transform → refine → analyse

## Governance
All rules derive from the SPECTRA Framework and are enforced by organisation guard workflows.
`;

            const gitignore =
`# SPECTRA standard ignores
*.pyc
__pycache__/
.ipynb_checkpoints/
.env
.DS_Store
*.log
*.sqlite
node_modules/
dist/
build/
`;

            const guard =
`name: repoStructureGuard
on:
  pull_request:
  push:
    branches: [ main, master, develop ]
jobs:
  validate:
    uses: SPECTRADataSolutions/.github/.github/workflows/repoStructureGuard.yml@main
    with:
      repoType: ${repoType}
`;

            const intent =
`dream: SPECTRA
pillar: ${pillar}
domain: ${domain}
capability: ${capability}
service: ${repo}
repoType: ${repoType}
visibility: ${visibility}
`;

            async function putFile(path, content, message){
              const b64 = Buffer.from(content,'utf8').toString('base64');
              await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, message, content: b64 });
            }

            await putFile('README.md', readme, 'chore: seed README with Pillar→Domain→Capability→Service nav');
            await putFile('.gitignore', gitignore, 'chore: add standard .gitignore');
            await putFile('.github/workflows/repoStructureGuard.yml', guard, 'ci: enable repoStructureGuard');
            await putFile('meta/intent.yml', intent, 'chore: add repo intent manifest');

      - name: protectMainBranch
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validateInputs.outputs.owner }}';
            const repo=core.getInput('repoName').trim();
            try {
              await github.rest.repos.updateBranchProtection({
                owner, repo, branch: 'main',
                required_status_checks: null,
                enforce_admins: true,
                required_pull_request_reviews: { required_approving_review_count: 1 },
                restrictions: null
              });
            } catch (e) {
              core.warning(`Branch protection not applied: ${e.message}`);
            }

      - name: applyServiceTopics
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validateInputs.outputs.owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim().toLowerCase();
            const domain=core.getInput('domain').trim().toLowerCase();
            const capability=core.getInput('capability').trim().toLowerCase();

            await github.rest.repos.replaceAllTopics({
              owner, repo,
              names: ['spectra','framework',`pillar-${pillar}`,`domain-${domain}`,`capability-${capability}`]
            });

      - name: outputResult
        run: echo "✅ Created or updated: ${{ steps.createRepository.outputs.repoUrl }}"