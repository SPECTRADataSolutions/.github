name: repoFactory
on:
  workflow_dispatch:
    inputs:
      repoName:
        description: "service (camelCase) — will become repository name"
        required: true
        type: string
      pillar:
        description: "Guidance|Innovation|Engagement|Operations|Protection|Sustenance|Growth"
        required: true
        type: string
      domain:
        description: "single-token camelCase (e.g. platformSecurity)"
        required: true
        type: string
      capability:
        description: "single-token camelCase (e.g. threatDetection)"
        required: true
        type: string
      repoType:
        description: "engineering|operations|applications|governance|content"
        required: true
        type: string
      visibility:
        description: "public or private"
        required: true
        type: string
        default: "private"
      description:
        description: "Short description of purpose and scope"
        required: true
        type: string
      homepage:
        description: "Optional homepage URL"
        required: false
        type: string

jobs:
  create:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: validate
        uses: actions/github-script@v7
        with:
          script: |
            const camel = /^[a-z][a-zA-Z0-9]*$/;
            const pillars = ['Guidance','Innovation','Engagement','Operations','Protection','Sustenance','Growth'];
            const types = ['engineering','operations','applications','governance','content'];
            const repoName = core.getInput('repoName').trim();
            const pillar = core.getInput('pillar').trim();
            const domain = core.getInput('domain').trim();
            const capability = core.getInput('capability').trim();
            const repoType = core.getInput('repoType').trim();
            const visibility = core.getInput('visibility').trim().toLowerCase();
            if (!camel.test(repoName)) core.setFailed(`repoName must be camelCase: ${repoName}`);
            if (!camel.test(domain)) core.setFailed(`domain must be camelCase: ${domain}`);
            if (!camel.test(capability)) core.setFailed(`capability must be camelCase: ${capability}`);
            if (!pillars.includes(pillar)) core.setFailed(`pillar invalid: ${pillar}`);
            if (!types.includes(repoType)) core.setFailed(`repoType invalid: ${repoType}`);
            if (!['public','private'].includes(visibility)) core.setFailed(`visibility invalid: ${visibility}`);
            core.setOutput('owner', context.repo.owner);

      - name: createRepo
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner = '${{ steps.validate.outputs.owner }}';
            const name = core.getInput('repoName').trim();
            const description = core.getInput('description').trim();
            const homepage = core.getInput('homepage') || undefined;
            const isPrivate = core.getInput('visibility').trim().toLowerCase() !== 'public';
            try {
              await github.rest.repos.get({ owner, repo: name });
              core.notice(`Repository already exists: ${owner}/${name}`);
              core.setOutput('repoUrl', `https://github.com/${owner}/${name}`);
            } catch (e) {
              if (e.status !== 404) throw e;
              const created = await github.rest.repos.createInOrg({
                org: owner, name, description, homepage,
                private: isPrivate, auto_init: true, has_issues: true, has_projects: true, has_wiki: false
              });
              core.setOutput('repoUrl', created.data.html_url);
            }

      - name: seedLabels
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validate.outputs.owner }}', repo=core.getInput('repoName').trim();
            const res = await github.rest.repos.getContent({ owner, repo: '.github', path: '.github/labels.json' });
            const labels = JSON.parse(Buffer.from(res.data.content,'base64').toString('utf8'));
            for (const l of labels) {
              try { await github.rest.issues.createLabel({ owner, repo, name: l.name, color: l.color, description: l.description }); }
              catch(e){ if(e.status===422){ await github.rest.issues.updateLabel({ owner, repo, name: l.name, color: l.color, description: l.description }); } else { throw e; } }
            }

      - name: writeFiles
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validate.outputs.owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim();
            const domain=core.getInput('domain').trim();
            const capability=core.getInput('capability').trim();
            const repoType=core.getInput('repoType').trim();
            const description=core.getInput('description').trim();

            const typeStructure = {
              'engineering': '- stages/\\n- utils/\\n- principles/\\n- conventions/\\n- Tables/',
              'governance': '- roles/\\n- contracts/\\n- specs/\\n- tools/',
              'operations': '- templates/\\n- scripts/\\n- docs/',
              'applications': '- src/\\n- components/\\n- pages/ or app/\\n- styles/',
              'content': '- knowledge/\\n- journal/\\n- discussions/\\n- templates/'
            };

            const readme = "# " + repo + "\\n\\n<!-- NAV_START -->\\n**Dream**: SPECTRA\\n**Pillar**: " + pillar + "\\n**Domain**: " + domain + "\\n**Capability**: " + capability + "\\n**Service**: " + owner + "/" + repo + "\\n<!-- NAV_END -->\\n\\n> " + description + "\\n\\n## Purpose\\nThis service delivers the " + capability + " capability within the " + domain + " domain of the " + pillar + " pillar.\\n\\n## Structure\\n- docs/\\n- scripts/\\n- .github/workflows/\\n- tests/\\n- meta/\\n" + (typeStructure[repoType] || '') + "\\n\\n## Governance\\nAll rules derive from the SPECTRA Framework. Enforced by org guard workflows.";

            const gitignore = "# SPECTRA standard ignores\\n*.pyc\\n__pycache__/\\n.ipynb_checkpoints/\\n.env\\n.DS_Store\\n*.log\\n*.sqlite\\nnode_modules/\\ndist/\\nbuild/";

            const guard = "name: repoStructureGuard\\non:\\n  pull_request:\\n  push:\\n    branches: [ main, master, develop ]\\njobs:\\n  validate:\\n    uses: SPECTRADataSolutions/.github/.github/workflows/repo-structure-guard.yml@main\\n    with:\\n      repoType: " + repoType;

            const intent = "dream: SPECTRA\\npillar: " + pillar + "\\ndomain: " + domain + "\\ncapability: " + capability + "\\nservice: " + repo + "\\nrepoType: " + repoType + "\\nvisibility: " + core.getInput('visibility').trim().toLowerCase();

            async function put(path, content, message){
              const b64 = Buffer.from(content,'utf8').toString('base64');
              await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, message, content: b64 });
            }
            await put('README.md', readme, 'chore: seed README with Pillar→Domain→Capability→Service nav');
            await put('.gitignore', gitignore, 'chore: add standard .gitignore');
            await put('.github/workflows/repoStructureGuard.yml', guard, 'ci: enable repoStructureGuard');
            await put('meta/intent.yml', intent, 'chore: add repo intent manifest');

      - name: protectMain
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validate.outputs.owner }}', repo=core.getInput('repoName').trim();
            try {
              await github.rest.repos.updateBranchProtection({
                owner, repo, branch: 'main',
                required_status_checks: null, enforce_admins: true,
                required_pull_request_reviews: { required_approving_review_count: 1 },
                restrictions: null
              });
            } catch (e) {
              core.warning(`Branch protection not applied: ${e.message}`);
            }

      - name: topics
        uses: actions/github-script@v7
        env:
          ORG_ADMIN_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          github-token: ${{ env.ORG_ADMIN_TOKEN }}
          script: |
            const owner='${{ steps.validate.outputs.owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim().toLowerCase();
            const domain=core.getInput('domain').trim();
            const capability=core.getInput('capability').trim();
            await github.rest.repos.replaceAllTopics({
              owner, repo,
              names: ['spectra','framework','pillar-'+pillar,'domain-'+domain,'capability-'+capability]
            });

      - name: output
        run: echo "✅ Created or updated repo at ${{ steps.createRepo.outputs.repoUrl }}"