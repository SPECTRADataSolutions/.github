name: generate-repository-service

# Unified canonical workflow (previously nested). Supports direct dispatch and reuse.
on:
  workflow_dispatch:
    inputs:
      repoName:
        description: "service (camelCase) — becomes repository name"
        required: true
        type: string
      pillar:
        description: "Guidance|Innovation|Engagement|Execution|Protection|Sustenance|Growth"
        required: true
        type: string
      domain:
        description: "single-token camelCase (e.g. platformSecurity)"
        required: true
        type: string
      capability:
        description: "single-token camelCase (e.g. threatDetection)"
        required: true
        type: string
      repoType:
        description: "engineering|execution|applications|governance|content"
        required: true
        type: string
      visibility:
        description: "public or private"
        required: true
        type: string
        default: private
      description:
        description: "Short description of purpose and scope"
        required: true
        type: string
      homepage:
        description: "Optional homepage URL"
        required: false
        type: string
  workflow_call:
    inputs:
      repoName:
        description: "service (camelCase) — becomes repository name"
        type: string
        required: true
      pillar:
        description: "Guidance|Innovation|Engagement|Execution|Protection|Sustenance|Growth"
        type: string
        required: true
      domain:
        description: "single-token camelCase (e.g. platformSecurity)"
        type: string
        required: true
      capability:
        description: "single-token camelCase (e.g. threatDetection)"
        type: string
        required: true
      repoType:
        description: "engineering|execution|applications|governance|content"
        type: string
        required: true
      visibility:
        description: "public or private"
        type: string
        default: private
        required: true
      description:
        description: "Short description of purpose and scope"
        type: string
        required: true
      homepage:
        description: "Optional homepage URL"
        type: string
        required: false
    secrets:
      SPECTRA_GOV_REPO_FACTORY_APP_ID:
        required: true
      SPECTRA_GOV_REPO_FACTORY_APP_PRIVATE_KEY:
        required: true
      SPECTRA_GOV_REPO_FACTORY_INSTALLATION_ID:
        required: true

# Permissions needed to create repos, seed files, apply labels
permissions:
  contents: write
  issues: write

jobs:
  create:
    runs-on: ubuntu-latest
    steps:
      - name: authenticate-github-app
        id: app-auth
        env:
          APP_ID: ${{ secrets.SPECTRA_GOV_REPO_FACTORY_APP_ID }}
          APP_PK: ${{ secrets.SPECTRA_GOV_REPO_FACTORY_APP_PRIVATE_KEY }}
          INSTALLATION_ID: ${{ secrets.SPECTRA_GOV_REPO_FACTORY_INSTALLATION_ID }}
        uses: actions/github-script@v7
        with:
          script: |
            const crypto = require('crypto');
            function b64(obj){return Buffer.from(JSON.stringify(obj)).toString('base64url');}
            const now = Math.floor(Date.now()/1000);
            const payload = { iat: now-60, exp: now+600, iss: process.env.APP_ID };
            const header = { alg:'RS256', typ:'JWT' };
            const signingInput = b64(header)+'.'+b64(payload);
            const sign = crypto.createSign('RSA-SHA256');
            sign.update(signingInput).end();
            const jwt = signingInput+'.'+sign.sign(process.env.APP_PK,'base64url');
            const instId = process.env.INSTALLATION_ID;
            const { data: tokenData } = await github.request('POST /app/installations/{installation_id}/access_tokens', { installation_id: instId, headers:{ Authorization: `Bearer ${jwt}`, Accept: 'application/vnd.github+json' }});
            core.setSecret(tokenData.token);
            core.setOutput('token', tokenData.token);
      - name: fetch-pillar-policy
        id: pillarPolicy
        uses: ./.github/actions/fetch-policy
        with:
          file: pillars.policy.json
      - name: validate-inputs
        id: validateInputs
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const camel = /^[a-z][a-zA-Z0-9]*$/;
            let pillars = [];
            try { const policy = JSON.parse(`${{ steps.pillarPolicy.outputs.content }}`); pillars = policy.canonical || []; } catch(e){ core.warning('Policy parse failed, fallback to static list'); pillars=['Guidance','Innovation','Engagement','Execution','Protection','Sustenance','Growth']; }
            const types = ['engineering','operations','applications','governance','content'];
            const get = n => (core.getInput(n) || '').trim();
            const repoName = get('repoName');
            const pillar = get('pillar');
            const domain = get('domain');
            const capability = get('capability');
            const repoType = get('repoType');
            const visibility = get('visibility').toLowerCase();
            const errs = [];
            if (!camel.test(repoName)) errs.push(`repoName must be camelCase: ${repoName}`);
            if (!camel.test(domain)) errs.push(`domain must be camelCase: ${domain}`);
            if (!camel.test(capability)) errs.push(`capability must be camelCase: ${capability}`);
            if (!pillars.includes(pillar)) errs.push(`pillar invalid: ${pillar}`);
            if (!types.includes(repoType)) errs.push(`repoType invalid: ${repoType}`);
            if (!['public','private'].includes(visibility)) errs.push(`visibility invalid: ${visibility}`);
            if (errs.length) core.setFailed(errs.join('\n'));
            core.summary.addHeading('Repository Service Generation Validation')
              .addList(errs.length ? errs : ['All inputs valid'])
              .write();
            core.setOutput('owner', context.repo.owner);
      - name: create-or-reuse-repository
        if: success()
        id: createRepo
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner = '${{ steps.validateInputs.outputs.owner || github.repository_owner }}';
            const name = (core.getInput('repoName')||'').trim();
            const description = (core.getInput('description')||'').trim();
            const homepage = (core.getInput('homepage') || '').trim() || undefined;
            const isPrivate = (core.getInput('visibility')||'').trim().toLowerCase() !== 'public';
            try {
              await github.rest.repos.get({ owner, repo: name });
              core.notice(`Repository already exists: ${owner}/${name}`);
            } catch (e) {
              if (e.status !== 404) throw e;
              const created = await github.rest.repos.createInOrg({
                org: owner,
                name,
                description,
                homepage,
                private: isPrivate,
                auto_init: true,
                has_issues: true,
                has_projects: true,
                has_wiki: false
              });
              core.notice(`Created repository: ${created.data.html_url}`);
              try { await github.rest.repos.update({ owner, repo: name, default_branch: 'main' }); } catch(err){ core.warning(`Default branch not set: ${err.message}`); }
            }
            core.setOutput('repoUrl', `https://github.com/${owner}/${name}`);
      - name: seed-labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            try {
              const res = await github.rest.repos.getContent({ owner, repo, path: '.github/labels.json' });
              const labels = JSON.parse(Buffer.from(res.data.content,'base64').toString('utf8'));
              for (const l of labels) {
                try { await github.rest.issues.createLabel({ owner, repo, name: l.name, color: l.color, description: l.description }); }
                catch(e){ if(e.status===422) await github.rest.issues.updateLabel({ owner, repo, name: l.name, color: l.color, description: l.description }); else throw e; }
              }
            } catch(err) { core.warning(`Labels not seeded: ${err.message}`); }
      - name: seed-initial-files
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim();
            const domain=core.getInput('domain').trim();
            const capability=core.getInput('capability').trim();
            const repoType=core.getInput('repoType').trim();
            const description=core.getInput('description').trim();
            const visibility=core.getInput('visibility').trim().toLowerCase();
            const readme=`# ${repo}\n\n**Dream**: SPECTRA  \n**Pillar**: ${pillar}  \n**Domain**: ${domain}  \n**Capability**: ${capability}  \n**Service**: ${owner}/${repo}\n\n> ${description}\n\n## Purpose\nDescribe purpose.\n`;
            const intent=`dream: SPECTRA\npillar: ${pillar}\ndomain: ${domain}\ncapability: ${capability}\nservice: ${repo}\nrepoType: ${repoType}\nvisibility: ${visibility}\n`;
            async function up(path, content, message){
              const b64=Buffer.from(content,'utf8').toString('base64');
              try { await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, message, content: b64 }); } catch(e){ core.warning(`${path} not written: ${e.message}`); }
            }
            await up('README.md', readme, 'chore: seed README');
            await up('meta/intent.yml', intent, 'chore: add intent manifest');
      - name: protect-main-branch
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            try { await github.rest.repos.updateBranchProtection({ owner, repo, branch: 'main', required_status_checks: null, enforce_admins: true, required_pull_request_reviews: { required_approving_review_count: 1 }, restrictions: null }); }
            catch(e){ core.warning(`Branch protection not applied: ${e.message}`); }
      - name: set-topics
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-auth.outputs.token }}
          script: |
            const owner='${{ github.repository_owner }}';
            const repo=core.getInput('repoName').trim();
            const pillar=core.getInput('pillar').trim().toLowerCase();
            const domain=core.getInput('domain').trim().toLowerCase();
            const capability=core.getInput('capability').trim().toLowerCase();
            try { await github.rest.repos.replaceAllTopics({ owner, repo, names: ['spectra','framework',`pillar-${pillar}`,`domain-${domain}`,`capability-${capability}`] }); } catch(e){ core.warning(`Topics not set: ${e.message}`); }
      - name: output-repo-url
        run: |
          echo "Repo URL: ${{ steps.createRepo.outputs.repoUrl }}"
