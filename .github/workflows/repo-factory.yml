name: repoFactory

on:
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read

jobs:
  provision:
    if: startsWith(github.event.comment.body, '/create-repo')
    runs-on: ubuntu-latest
    steps:
      - name: Validate org admin token present
        run: |
          if [ -z "${{ secrets.ORG_ADMIN_TOKEN }}" ]; then
            echo "❌ ORG_ADMIN_TOKEN is not configured in org or repo secrets"; exit 1;
          fi

      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const raw = context.payload.comment.body.trim();
            // Expected: /create-repo key=value key=value ...
            const args = raw.replace('/create-repo','').trim().split(/\s+/).filter(Boolean);
            const kv = {};
            for (const a of args) {
              const [k,...rest] = a.split('=');
              if (k && rest.length) kv[k] = rest.join('=');
            }
            // Support desc alias for description
            const description = kv.description || kv.desc || `SPECTRA capability repository for ${kv.domain || 'unspecified'} domain.`;
            const visibility = (kv.visibility || 'private').toLowerCase();
            const allowedVis = new Set(['private','public','internal']);
            if (!allowedVis.has(visibility)) {
              core.setFailed(`Invalid visibility: ${visibility}. Use public, private, or internal.`);
            }
            const out = {
              repoName: kv.repoName || '',
              visibility,
              description,
              domain: kv.domain || '',
              pillar: kv.pillar || '',
              capability: kv.capability || '',
              repoType: kv.repoType || '',
              templateRepo: kv.templateRepo || ''
            };
            if (!out.repoName) core.setFailed('Missing required param: repoName');
            if (!/^[a-z][a-zA-Z0-9]*$/.test(out.repoName)) core.setFailed('repoName must be single-token camelCase starting with lowercase');
            core.setOutput('repoName', out.repoName);
            core.setOutput('visibility', out.visibility);
            core.setOutput('description', out.description);
            core.setOutput('domain', out.domain);
            core.setOutput('pillar', out.pillar);
            core.setOutput('capability', out.capability);
            core.setOutput('repoType', out.repoType);
            core.setOutput('templateRepo', out.templateRepo);

      - name: Create repository
        id: create
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner; // organisation name
            const name = '${{ steps.parse.outputs.repoName }}';
            const visibility = '${{ steps.parse.outputs.visibility }}'; // public|private|internal
            const description = '${{ steps.parse.outputs.description }}';
            const templateRepo = '${{ steps.parse.outputs.templateRepo }}';
            const [tplOwner, tplName] = templateRepo && templateRepo.includes('/') ? templateRepo.split('/') : [null,null];

            // Ensure repository does not already exist
            try {
              await github.request('GET /repos/{owner}/{repo}', {
                owner, repo: name,
                headers: { authorization: `token ${process.env.GH_TOKEN}` }
              });
              core.setFailed(`Repository ${owner}/${name} already exists`);
              return;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            let created;
            if (tplOwner && tplName) {
              // Generate from template (endpoint supports 'private' boolean, not 'visibility')
              created = await github.request('POST /repos/{template_owner}/{template_repo}/generate', {
                template_owner: tplOwner,
                template_repo: tplName,
                owner,
                name,
                private: visibility !== 'public', // 'internal' will be created as private (API limitation)
                include_all_branches: false,
                description,
                headers: { authorization: `token ${process.env.GH_TOKEN}` }
              });
            } else {
              // Create blank repository with visibility
              created = await github.request('POST /orgs/{org}/repos', {
                org: owner,
                name,
                description,
                visibility, // supports public|private|internal
                has_issues: true,
                has_projects: false,
                has_wiki: false,
                auto_init: true,
                headers: { authorization: `token ${process.env.GH_TOKEN}` }
              });
            }

            const repoHtml = created.data.html_url;

            // Best-effort: enforce default branch 'main'
            try {
              await github.request('PATCH /repos/{owner}/{repo}', {
                owner, repo: name, default_branch: 'main',
                headers: { authorization: `token ${process.env.GH_TOKEN}` }
              });
            } catch(e) { /* no-op if already main or policy-managed */ }

            core.setOutput('repoHtml', repoHtml);

      - name: Seed labels from organisation canonical set
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner;
            const newRepo = '${{ steps.parse.outputs.repoName }}';
            // Load canonical labels.json from org .github repo
            const labelsContent = await github.request('GET /repos/{owner}/{repo}/contents/{path}', {
              owner, repo: '.github', path: '.github/labels.json',
              headers: { authorization: `token ${process.env.GH_TOKEN}` }
            });
            const buf = Buffer.from(labelsContent.data.content, labelsContent.data.encoding);
            const labels = JSON.parse(buf.toString('utf8'));

            for (const l of labels) {
              try {
                await github.request('POST /repos/{owner}/{repo}/labels', {
                  owner, repo: newRepo, name: l.name, color: l.color, description: l.description,
                  headers: { authorization: `token ${process.env.GH_TOKEN}` }
                });
              } catch (e) {
                if (e.status === 422) {
                  await github.request('PATCH /repos/{owner}/{repo}/labels/{name}', {
                    owner, repo: newRepo, name: l.name, new_name: l.name, color: l.color, description: l.description,
                    headers: { authorization: `token ${process.env.GH_TOKEN}` }
                  });
                } else {
                  throw e;
                }
              }
            }

      - name: Add baseline README and .gitignore (if not templated)
        if: steps.parse.outputs.templateRepo == ''
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ secrets.ORG_ADMIN_TOKEN }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = '${{ steps.parse.outputs.repoName }}';
            const readme = `# ${repo}

> SPECTRA capability repository — governed by the SPECTRA Framework.

## Purpose
Describe the capability this planet/repo owns.

## Structure
- source → extract → clean → transform → refine → analyse

## Framework
All standards, naming, and workflows are defined in the SPECTRA Framework. Do not define local standards.

## Getting Started
- Read the Framework
- Use organisation templates and workflows
`;
            const gitignore = `# Standard
*.pyc
__pycache__/
.ipynb_checkpoints/
.env
.DS_Store
*.log
`;
            const b64 = (s)=> Buffer.from(s,'utf8').toString('base64');
            await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
              owner, repo, path: 'README.md', message: 'chore: seed README', content: b64(readme),
              headers: { authorization: `token ${process.env.GH_TOKEN}` }
            });
            await github.request('PUT /repos/{owner}/{repo}/contents/{path}', {
              owner, repo, path: '.gitignore', message: 'chore: seed .gitignore', content: b64(gitignore),
              headers: { authorization: `token ${process.env.GH_TOKEN}` }
            });

      - name: Comment back with result
        uses: actions/github-script@v7
        with:
          script: |
            const repoUrl = '${{ steps.create.outputs.repoHtml }}';
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.payload.issue.number,
              body: `✅ Repository created: ${repoUrl}`
            });