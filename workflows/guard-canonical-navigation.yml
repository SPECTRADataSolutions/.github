name: guard-canonical-navigation

on:
  pull_request:
  issues:
    types: [opened, edited]

jobs:
  canonical-guard:
    runs-on: ubuntu-latest
    permissions:
      contents: read # only reads repo content for policy + README
      pull-requests: read # reviews PR diffs
      issues: write # needed to comment on issues & PR threads (issue API)
    steps:
      - name: fetch-acronym-policy
        if: github.event_name == 'pull_request'
        id: acronymPolicy
        uses: ./.github/actions/fetch-policy
        with:
          file: acronyms.policy.json
      - name: summarize-acronym-policy
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            core.summary.addHeading('Acronym Policy Integrity')
              .addRaw(`sha256: ${{ steps.acronymPolicy.outputs.sha256 }} path: ${{ steps.acronymPolicy.outputs.path }}`)
              .write();
      - name: check-pr-acronyms
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            let mapping={};
            try { mapping = JSON.parse(`${{ steps.acronymPolicy.outputs.content }}`).bannedAcronyms || {}; } catch(e){ core.warning('Acronym policy parse failed: '+e.message); }
            const banned = Object.keys(mapping);
            const { data: files } = await github.rest.pulls.listFiles({ ...context.repo, pull_number: context.payload.pull_request.number });
            const violations=[];
            for(const f of files){ if(!f.patch) continue; for(const line of f.patch.split('\n').filter(l=>l.startsWith('+'))){ for(const a of banned){ if(line.includes(a)) violations.push({file:f.filename,a,line:line.slice(1)}); } } }
            if(violations.length){
              const details=violations.map(v=>`- **${v.file}**: \`${v.a}\` ‚Üí replace with canonical archetype (${mapping[v.a]||'canonical term'})`).join('\n');
              await github.rest.issues.createComment({ ...context.repo, issue_number: context.payload.pull_request.number, body:[ '‚ùå Canonical navigation violation', details, '', 'Replace legacy acronyms with archetype names (see policies/acronyms.policy.json).' ].join('\n')});
              core.setFailed('Found legacy C*O acronyms');
            }
            core.summary.addHeading('Acronym Policy').addRaw(violations.length? `${violations.length} violations` : 'No violations').write();
      - name: validate-readme-nav
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const path='README.md';
            let content='';
            try{ const {data} = await github.rest.repos.getContent({...context.repo, path}); content=Buffer.from(data.content,'base64').toString('utf8'); }catch{}
            if(!content){ core.setFailed('README.md missing'); return; }
            const hasBlock=/<!-- NAV_START -->[\s\S]*<!-- NAV_END -->/m.test(content);
            if(!hasBlock){ core.setFailed('Missing NAV_START/NAV_END block'); }
      - name: check-issue-acronyms
        if: github.event_name == 'issues'
        uses: actions/github-script@v7
        with:
          script: |
            const text=(context.payload.issue.title||'') + ' ' + (context.payload.issue.body||'');
            const banned=['CFO','CTO','CIO','CMO','COO','CSO','CDO','CKO','CAO','COS','CEO'];
            const found=banned.filter(a=> text.includes(a));
            if(found.length){ await github.rest.issues.createComment({ ...context.repo, issue_number: context.issue.number, body:`üëã Replace legacy acronyms: ${found.join(', ')}`}); }
